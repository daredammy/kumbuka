#!/usr/bin/env -S uv run --quiet --script
# /// script
# requires-python = ">=3.10"
# dependencies = ["numpy", "sounddevice", "httpx"]
# ///
"""Record a meeting, transcribe with Whisper, send to Claude for summary + Notion."""

import io
import json
import signal
import sys
import subprocess
import wave
from datetime import datetime
from pathlib import Path

import httpx
import numpy as np
import sounddevice as sd

# Config
WHISPER_URL = "http://127.0.0.1:2022/v1/audio/transcriptions"
SAMPLE_RATE = 16000
CHANNELS = 1
TEMP_DIR = Path("/tmp/kumbuka")
MAX_DURATION = 7200  # 2 hours

# State
recording = True
chunks = []


def tone(freq=880, dur=0.15, vol=0.3):
    t = np.linspace(0, dur, int(SAMPLE_RATE * dur), False)
    wave = np.sin(freq * 2 * np.pi * t) * vol
    env = np.ones_like(wave)
    fade = int(SAMPLE_RATE * 0.01)
    env[:fade] = np.linspace(0, 1, fade)
    env[-fade:] = np.linspace(1, 0, fade)
    sd.play((wave * env * 32767).astype(np.int16), SAMPLE_RATE)
    sd.wait()


def start_tone():
    tone(660, 0.1)
    tone(880, 0.15)


def stop_tone():
    tone(880, 0.1)
    tone(660, 0.15)


def on_signal(sig, frame):
    global recording
    recording = False


def record():
    global recording, chunks
    TEMP_DIR.mkdir(parents=True, exist_ok=True)
    session = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    
    signal.signal(signal.SIGINT, on_signal)
    
    def callback(indata, frames, time, status):
        if recording:
            chunks.append(indata.copy())
    
    start_tone()
    print(f"\nüéôÔ∏è  RECORDING STARTED")
    print(f"   Press Ctrl+C to stop\n")
    
    with sd.InputStream(samplerate=SAMPLE_RATE, channels=CHANNELS, dtype=np.int16, callback=callback):
        start = datetime.now()
        last = -1
        while recording:
            sd.sleep(100)
            elapsed = (datetime.now() - start).seconds
            if elapsed >= MAX_DURATION:
                print(f"\n‚è±Ô∏è  Max duration reached")
                break
            if elapsed % 5 == 0 and elapsed != last and elapsed > 0:
                last = elapsed
                m, s = divmod(elapsed, 60)
                dot = "üî¥" if (elapsed // 5) % 2 == 0 else "‚ö´"
                print(f"   {dot} Recording: {m:02d}:{s:02d}")
    
    stop_tone()
    print(f"\nüõë Recording stopped")
    
    if not chunks:
        print("‚ùå No audio recorded")
        return None, None
    
    audio = np.concatenate(chunks)
    buf = io.BytesIO()
    with wave.open(buf, 'wb') as w:
        w.setnchannels(CHANNELS)
        w.setsampwidth(2)
        w.setframerate(SAMPLE_RATE)
        w.writeframes(audio.tobytes())
    buf.seek(0)
    wav = buf.read()
    
    audio_path = TEMP_DIR / f"{session}.wav"
    audio_path.write_bytes(wav)
    
    dur = len(wav) / (SAMPLE_RATE * 2)
    m, s = divmod(int(dur), 60)
    print(f"üíæ Saved: {audio_path} ({m}m {s}s)")
    
    return wav, session


def transcribe(wav: bytes, session: str):
    print(f"\nüìù Transcribing with Whisper...")
    
    with httpx.Client(timeout=600) as client:
        resp = client.post(
            WHISPER_URL,
            files={"file": ("audio.wav", wav, "audio/wav")},
            data={"model": "whisper-1", "response_format": "json"}
        )
        resp.raise_for_status()
        text = resp.json().get("text", "")
    
    if text:
        path = TEMP_DIR / f"{session}.txt"
        path.write_text(text)
        print(f"üíæ Saved: {path} ({len(text)} chars)")
    
    return text


def send_to_claude(transcript: str, duration: str, timestamp: str):
    print(f"\nü§ñ Sending to Claude...")
    
    prompt = f'''I just recorded a meeting. Process it and create a Notion page.

**Recorded:** {timestamp}
**Duration:** {duration}

**Raw Transcript:**
{transcript}

---

**Instructions:**

1. **PARTICIPANTS**: Identify speakers and their roles/functions if discernible from context (e.g., "Sarah (Engineering Lead)", "John (Client, Acme Corp)", "Me (Host)"). List them at the top of the page. If roles aren't clear, just use names or Speaker 1/2/etc.

2. **TITLE**: Generate a concise, descriptive title based on the meeting content (e.g., "Product Roadmap Planning Q1", "1:1 with Sarah - Career Growth", "Client Onboarding: Acme Corp"). Do NOT use generic titles like "Meeting - December 15".

3. **SUMMARY**: Create a summary with sections appropriate to THIS meeting's content. Every meeting is different - adapt the structure. However, ALWAYS include these two sections if applicable:
   - **Decisions** (any decisions made)
   - **Action Items** (with owners if mentioned)
   
   Other sections to include as relevant: Overview, Key Discussion Points, Open Questions, Next Steps, Blockers, Feedback, etc.

4. **CLEANED TRANSCRIPT**: Fix grammar, remove filler words (um, uh, like), format into readable paragraphs. Attribute statements to speakers where possible (e.g., "**Sarah:** We should prioritize the API work first.").

5. **CREATE NOTION PAGE** in the Meetings database:
   https://www.notion.so/Meetings-2caadf3d26ca80089ec3f241c6262dd4
   
   Use the generated title as the page title. Include participants, summary, then the cleaned transcript.
'''
    
    claude_path = Path.home() / ".npm-global/bin/claude"
    subprocess.run([str(claude_path), "-p", prompt])


def main():
    wav, session = record()
    if not wav:
        sys.exit(1)
    
    transcript = transcribe(wav, session)
    if not transcript:
        print("‚ùå Transcription failed")
        sys.exit(1)
    
    dur = len(wav) / (SAMPLE_RATE * 2)
    m, s = divmod(int(dur), 60)
    
    send_to_claude(transcript, f"{m}m {s}s", datetime.now().strftime("%Y-%m-%d %H:%M"))
    print("\n‚úÖ Done!")


if __name__ == "__main__":
    main()
