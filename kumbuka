#!/usr/bin/env -S uv run --quiet --script
# /// script
# requires-python = ">=3.10"
# dependencies = ["numpy", "sounddevice", "httpx"]
# ///
"""
Kumbuka - Local-first meeting recorder with AI-powered transcription.
https://github.com/hypebridge/kumbuka
"""

import io
import json
import os
import signal
import sys
import shutil
import subprocess
import wave
from datetime import datetime
from pathlib import Path

import httpx
import numpy as np
import sounddevice as sd

# =============================================================================
# CONFIGURATION - Edit these or set via environment variables
# =============================================================================

# Whisper server URL (default: VoiceMode's whisper server)
WHISPER_URL = os.getenv("KUMBUKA_WHISPER_URL", "http://127.0.0.1:2022/v1/audio/transcriptions")

# Notion database URL - SET THIS TO YOUR OWN MEETINGS DATABASE
# To find it: Open your Notion database, click "..." > "Copy link"
NOTION_DB_URL = os.getenv("KUMBUKA_NOTION_URL", "")

# Max recording duration in seconds (default: 2 hours)
MAX_DURATION = int(os.getenv("KUMBUKA_MAX_DURATION", "7200"))

# =============================================================================

SAMPLE_RATE = 16000
CHANNELS = 1
TEMP_DIR = Path("/tmp/kumbuka")

recording = True
chunks = []


def tone(freq=880, dur=0.15, vol=0.3):
    t = np.linspace(0, dur, int(SAMPLE_RATE * dur), False)
    w = np.sin(freq * 2 * np.pi * t) * vol
    env = np.ones_like(w)
    fade = int(SAMPLE_RATE * 0.01)
    env[:fade] = np.linspace(0, 1, fade)
    env[-fade:] = np.linspace(1, 0, fade)
    sd.play((w * env * 32767).astype(np.int16), SAMPLE_RATE)
    sd.wait()


def start_tone():
    tone(660, 0.1)
    tone(880, 0.15)


def stop_tone():
    tone(880, 0.1)
    tone(660, 0.15)


def on_signal(sig, frame):
    global recording
    recording = False


def find_claude():
    """Find claude CLI in PATH or common locations."""
    # Check PATH first
    claude = shutil.which("claude")
    if claude:
        return claude
    
    # Check common locations
    locations = [
        Path.home() / ".npm-global/bin/claude",
        Path.home() / ".local/bin/claude",
        Path("/usr/local/bin/claude"),
    ]
    for loc in locations:
        if loc.exists():
            return str(loc)
    
    return None


def check_requirements():
    """Check that all requirements are met."""
    errors = []
    
    # Check Whisper
    try:
        resp = httpx.get(WHISPER_URL.replace("/v1/audio/transcriptions", "/health"), timeout=2)
    except:
        errors.append(f"‚ùå Whisper not running at {WHISPER_URL}\n   Start it with: voicemode start-service whisper")
    
    # Check Claude
    if not find_claude():
        errors.append("‚ùå Claude CLI not found\n   Install with: npm install -g @anthropic-ai/claude-code")
    
    # Check Notion URL
    if not NOTION_DB_URL:
        errors.append("‚ùå Notion database URL not set\n   Set KUMBUKA_NOTION_URL environment variable or edit the script")
    
    if errors:
        print("\n‚ö†Ô∏è  Setup incomplete:\n")
        for e in errors:
            print(f"   {e}\n")
        print("See README.md for setup instructions.")
        sys.exit(1)


def record_audio():
    global recording, chunks
    TEMP_DIR.mkdir(parents=True, exist_ok=True)
    session = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    
    signal.signal(signal.SIGINT, on_signal)
    
    def callback(indata, frames, time, status):
        if recording:
            chunks.append(indata.copy())
    
    start_tone()
    print(f"\nüéôÔ∏è  RECORDING STARTED")
    print(f"   Press Ctrl+C to stop\n")
    
    with sd.InputStream(samplerate=SAMPLE_RATE, channels=CHANNELS, dtype=np.int16, callback=callback):
        start = datetime.now()
        last = -1
        while recording:
            sd.sleep(100)
            elapsed = (datetime.now() - start).seconds
            if elapsed >= MAX_DURATION:
                print(f"\n‚è±Ô∏è  Max duration reached")
                break
            if elapsed % 5 == 0 and elapsed != last and elapsed > 0:
                last = elapsed
                m, s = divmod(elapsed, 60)
                dot = "üî¥" if (elapsed // 5) % 2 == 0 else "‚ö´"
                print(f"   {dot} Recording: {m:02d}:{s:02d}")
    
    stop_tone()
    print(f"\nüõë Recording stopped")
    
    if not chunks:
        print("‚ùå No audio recorded")
        return None, None
    
    audio = np.concatenate(chunks)
    buf = io.BytesIO()
    with wave.open(buf, 'wb') as w:
        w.setnchannels(CHANNELS)
        w.setsampwidth(2)
        w.setframerate(SAMPLE_RATE)
        w.writeframes(audio.tobytes())
    buf.seek(0)
    wav = buf.read()
    
    audio_path = TEMP_DIR / f"{session}.wav"
    audio_path.write_bytes(wav)
    
    dur = len(wav) / (SAMPLE_RATE * 2)
    m, s = divmod(int(dur), 60)
    print(f"üíæ Saved: {audio_path} ({m}m {s}s)")
    
    return wav, session


def transcribe(wav: bytes, session: str):
    print(f"\nüìù Transcribing with Whisper...")
    
    with httpx.Client(timeout=600) as client:
        resp = client.post(
            WHISPER_URL,
            files={"file": ("audio.wav", wav, "audio/wav")},
            data={"model": "whisper-1", "response_format": "json"}
        )
        resp.raise_for_status()
        text = resp.json().get("text", "")
    
    if text:
        path = TEMP_DIR / f"{session}.txt"
        path.write_text(text)
        print(f"üíæ Saved: {path} ({len(text)} chars)")
    
    return text


def send_to_claude(transcript: str, duration: str, timestamp: str):
    print(f"\nü§ñ Sending to Claude...")
    
    prompt = f'''I just recorded a meeting. Process it and create a Notion page.

**Recorded:** {timestamp}
**Duration:** {duration}

**Raw Transcript:**
{transcript}

---

**Instructions:**

1. **PARTICIPANTS**: Identify speakers and their roles/functions if discernible from context (e.g., "Sarah (Engineering Lead)", "John (Client, Acme Corp)", "Me (Host)"). List them at the top of the page. If roles aren't clear, just use names or Speaker 1/2/etc.

2. **TITLE**: Generate a concise, descriptive title based on the meeting content (e.g., "Product Roadmap Planning Q1", "1:1 with Sarah - Career Growth", "Client Onboarding: Acme Corp"). Do NOT use generic titles like "Meeting - December 15".

3. **SUMMARY**: Create a summary with sections appropriate to THIS meeting's content. Every meeting is different - adapt the structure. However, ALWAYS include these two sections if applicable:
   - **Decisions** (any decisions made)
   - **Action Items** (with owners if mentioned)
   
   Other sections to include as relevant: Overview, Key Discussion Points, Open Questions, Next Steps, Blockers, Feedback, etc.

4. **CLEANED TRANSCRIPT**: Fix grammar, remove filler words (um, uh, like), format into readable paragraphs. Attribute statements to speakers where possible (e.g., "**Sarah:** We should prioritize the API work first.").

5. **CREATE NOTION PAGE** in the Meetings database:
   {NOTION_DB_URL}
   
   Use the generated title as the page title. Include participants, summary, then the cleaned transcript.
'''
    
    claude = find_claude()
    subprocess.run([claude, "-p", prompt])


def main():
    check_requirements()
    
    wav, session = record_audio()
    if not wav:
        sys.exit(1)
    
    transcript = transcribe(wav, session)
    if not transcript:
        print("‚ùå Transcription failed")
        sys.exit(1)
    
    dur = len(wav) / (SAMPLE_RATE * 2)
    m, s = divmod(int(dur), 60)
    
    send_to_claude(transcript, f"{m}m {s}s", datetime.now().strftime("%Y-%m-%d %H:%M"))
    print("\n‚úÖ Done!")


if __name__ == "__main__":
    main()
